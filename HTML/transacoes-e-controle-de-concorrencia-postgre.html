<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercícios</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../CSS/desafios-projetos.css">
</head>
<body>
    <header>
        <h1>Exercícios de Transações e Controle de Concorrência.</h1>
        <nav>
            <ul>
                <li><a href="../HTML/postgresql-exercises.html">Voltar</a></li>
                <li><a href="../index.html">Início</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
            <ul>
                <li>Crie uma transação básica usando os comandos `BEGIN`, `COMMIT` e `ROLLBACK`.</li>
                <li>Teste a transação com múltiplas instruções `INSERT`, `UPDATE` e `DELETE` para garantir a atomicidade.</li>
                <li>Verifique o isolamento de transações usando diferentes níveis de isolamento: `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ` e `SERIALIZABLE`.</li>
                <li>Simule um cenário de concorrência em que duas transações tentam atualizar o mesmo registro simultaneamente e observe o efeito de bloqueios.</li>
                <li>Utilize o comando `SELECT FOR UPDATE` para bloquear linhas enquanto uma transação está em andamento.</li>
                <li>Explore o comando `SAVEPOINT` para criar pontos de restauração dentro de uma transação e pratique o uso de `ROLLBACK TO SAVEPOINT`.</li>
                <li>Teste a detecção de deadlocks configurando transações que resultem em conflitos e observe como o PostgreSQL resolve esses problemas.</li>
                <li>Realize operações de leitura com o nível de isolamento `SERIALIZABLE` e compare o desempenho com outros níveis de isolamento.</li>
                <li>Use o comando `pg_stat_activity` para monitorar as transações em execução e identificar transações em espera.</li>
                <li>Explore a configuração de `lock_timeout` para controlar o tempo máximo de espera por um bloqueio de recurso.</li>
                <li>Crie um script de transação que envolva múltiplas tabelas e que utilize `BEGIN`, `COMMIT`, e `ROLLBACK` para garantir integridade referencial.</li>
                <li>Simule uma situação de leitura fantasma em um cenário de transação e observe como o PostgreSQL lida com isso com o isolamento `REPEATABLE READ`.</li>
                <li>Teste o controle de concorrência otimista usando `SELECT ... FOR SHARE` para permitir que transações leiam dados enquanto outra transação os atualiza.</li>
                <li>Crie uma transação com uma instrução de `UPDATE` e utilize um `WHERE` com uma condição para limitar a atualização a linhas específicas.</li>
                <li>Pratique a criação de transações aninhadas com o uso de `BEGIN` e `COMMIT` em transações internas.</li>
                <li>Simule um cenário de bloqueio exclusivo onde uma transação impede outras de acessar um recurso por completo.</li>
                <li>Utilize a cláusula `NOWAIT` no comando `SELECT FOR UPDATE NOWAIT` para retornar um erro se a linha estiver bloqueada.</li>
                <li>Explore o uso de `EXPLICIT LOCKS` em tabelas com o comando `LOCK TABLE` para obter um bloqueio exclusivo em uma tabela inteira.</li>
                <li>Observe como o PostgreSQL trata transações em segundo plano utilizando o comando `pg_terminate_backend` para encerrar transações que estão em deadlock.</li>
                <li>Pratique o uso de transações em um ambiente de alta concorrência com múltiplas conexões simulando operações de escrita e leitura.</li>
                <li>Testar a recuperação de transações em caso de falha com o `WAL (Write Ahead Logging)` e `pg_xlog`.</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Bom Estudo.</p>
    </footer>
</body>
</html>

